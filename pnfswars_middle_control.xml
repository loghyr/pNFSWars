<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section anchor="sec:control" title="The Control Protocol">
  <t>
    In Section 12.2.6 of <xref target='RFC5661' />, the control
    protocol was introduced.  There have been no published specifications
    for control protocols as yet.  The control protocol denotes
    any mechanism used to meet the requirements that apply to the
    interaction between the metadata server and the storage device
    such that they present a consistent interface to the client.
    Particular implementations may satisfy this requirement in any
    manner they choose and the mechanism chosen may not be described as
    a protocol.  Specifications defining Layout Types need to clearly
    show how implementations can meet the requirements discussed below,
    especially with respect to those that have security implications.
    In addition, such specifications may find it necessary to impose
    requirements on implementations of the layout type to ensure
    appropriate interoperability.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    protocol.  This is often described as using a "loose coupling" model.
    In such cases, the assumption is that the metadata server,
    storage devices, and client may be changed independently and that
    the implementation requirements in the layout type specification
    need to ensure this degree of interoperability.  This model is used
    in the block and object layout type specification.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    In other cases, it is assumed that there may be purpose-built control
    protocol which may be different for different implementations of the
    metadata server and data server.  In such cases, the assumption is
    that the metadata server and data servers are designed and implemented
    as a unit and interoperability needs to be assured between clients
    and metadata-data server pairs, developed independently. This is
    the model used for the files layout.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    Another possibility, not so far realized, is for the definition of
    a control protocol to be specified in a standards-track document.
    There are two subcases to consider:

    <list style='symbols'>
      <t>
        A new layout type includes a definition of a particular
        control protocol whose use is obligatory for metadata serverss
        and storage devices implementing the layout type.  In this case
        the interoperability model is similar to the first case above
        and the defining document should assure interoperability among
        metadata servers, storage devices, and clients developed
        independently.
      </t>

      <t>
        A control protocol is defined in a standards-track document
        which meets the control protocol requirements for one of the
        existing layout types.  In this case, the new document's job
        is to assure interoperability between metadata servers and
        storage devices developed separately.  The existing  definition
        document for the selected layout type retains the function of
        assuring interoperability between clients and a given collection
        of metadata servers and storage devices.  In this context,
        implementations that implement the new protocol are treated in
        the same way as those that use an internal control protocol or
        a functional equivalent.
      </t>
    </list>
  </t>

  <section anchor="sec:control:req" title="Protocol REQUIREMENTS">
    <t>
      The REQUIREMENTS of such interactions between the metadata
      server and the storage devices are:

      <list style='format (%d)'>
        <t>
          The metadata server MUST be able to service the client's
          I/O requests if the client decides to make such requests
          to the metadata server instead of to the storage device.
          The metadata server must be able to retrieve the data
          from the constituent storage devices and present it back
          to the client.  A corollary to this is that even though
          the metadata server has successfully given the client
          a layout, the client MAY still send I/O requests to the
          metadata server.
          <vspace blankLines="1" />
          Whether the metadata server allows access over other protocols
          (e.g., NFSv3, Server Message Block (SMB), etc) is strictly an
          implementation choice, just as it is in the case of any other
          (i.e., non-pNFS-supporting) NFSv4.1 server.
        </t>

        <t>
          The metadata server MUST be able to restrict access to a file
          on the storage devices when it revokes a layout. The metadata
          server typically would revoke a layout whenever a client fails
          to respond to a recall or a client's lease is expired due to
          non-renewal. It might also revoke the layout as a means of
          enforcing a change in locking state or access permissions that
          the storage device cannot directly enforce.
          <vspace blankLines="1" />
          Effective revocation may require client co-operation in using a
          particular stateid (files layout) or principal (e,g., flexible
          files layout) when performing I/O.
        </t>

        <t>
          A pNFS impelementation MUST NOT remove NFSv4.1's access
          controls: ACLs and file open modes. While Section 12.9 of
          <xref target='RFC5661' /> specifically lays this burden on
          the combination of clients, storage devices, and the
          metadata server, depending on the implementation, there
          might be a requirement that the metadata server update
          the storage device such that it can enforce security.
          <vspace blankLines="1" />
          The file layout requires the storage device to enforce
          access whereas the flex file layout requires both the
          storage device and the client to enforce security.
        </t>

        <t>
          Locking MUST be respected.
        </t>

        <t>
          The metadata server and the storage devices MUST agree on 
          attributes like modify time, the change attribute, and
          the end-of-file (EOF) position.

          <list style='format (%c)'>
            <t>
              "Agree" in the sense that some while state changes
              need not be propagated immediately, they must be
              propagated when accessed by the client. This access
              is typically in response to a GETATTR of those
              attributes.
            </t>

            <t>
              A particular storage device might be striped such
              it knows nothing about the EOF position.  It still
              meets the requirement of agreeing on that fact with
              the metadata server.
            </t>

            <t>
              Both clock skew and network delay can lead to
              the metadata server and the storage device having
              different concepts of the time attributes. As long
              as those differences can be accounted for what is
              presented to the client in a GETATTR, then the
              two "agree".
            </t>

            <t>
              A LAYOUTCOMMIT requires that storage device generated
              changes in attributes need be reflected in the metadata
              server by the completion of the operation.
            </t>
          </list>
        </t>
      </list>
    </t>

    <t>
      These requirements may be satisfied in different ways by different
      Layout Types. As an example, while the file layout type does use
      the stateid to fence off the client, there is no requirement that
      other layout types use this stateid approach.
    </t>

    <t>
      Each new standards-track document for a layout types MUST
      address how the client, metadata server, and storage devices
      interact to meet these requirements.
    </t>
  </section>

  <section anchor="sec:control:nonreq" title="Protocol Non-REQUIREMENTS">
    <t>
      In gathering the requirements from Section 12 of <xref
      target='RFC5661' />, there are some which are notable in their
      absence:

      <list style='format (%d)'>
        <t>
          Storage devices MUST honor the byte range restrictions present
          in the layout. I.e., if the layout only provides access to
          the first 2 MB of the file, then any access after that MUST
          NOT be granted.
        </t>

        <t>
          The enforcement of authentication and authorization so that
          restrictions that would be enforced by the metadata server
          are also enforced by the storage device.  Examples include
          both export access checks and if the layout has an iomode
          of LAYOUTIOMODE4_READ, then if the client attempts to write,
          the I/O may be rejected.
          <vspace blankLines="1"/>

          While storage devices should make such checks on the layout
          iomode, <xref target='RFC5661' /> does not mandate that all
          layout types have to make such checks.
        </t>

        <t>
          The allocation and deallocation of storage. I.e., creating
          and deleting files.
        </t>
      </list>
    </t>

    <t>
      Of these, the first two are of concern to this draft and layout
      types SHOULD honor them if at all possible,
    </t>
  </section>

  <section anchor="sec:control:edits" title="Editorial Requirements">
    <t>
      In addition to these protocol requirements, there are two editorial
      requirements for drafts that present a new layout type. At a
      minimum, the specification needs to address:

      <list style='format (%d)'>
        <t>
          The approach the new layout type takes towards fencing clients once the
          metadata server determines that the layout is revoked.
        </t>

        <t>
          The security considerations of the new layout type.
        </t>
      </list>

      While these could be envisioned as one section in that the fencing issue might be
      the only security issue, it is recommended to deal with them separably.
    </t>

    <t>
      The specification of the layout type should discuss how the client, metadata server,
      and storage device act together to meet the protocol requirements. I.e., if the storage
      device cannot enforce mandatory byte-range locks, then how can the metadata
      server and the client interact with the layout to enforce those locks?
    </t>
  </section>
</section>
