<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section anchor="sec:control" title="The Control Protocol">
  <t>
    In Section 12.2.6 of <xref target='RFC5661' />, the control
    protocol was introduced.  There have been no published specifications
    for control protocols as yet.  The control protocol denotes
    any mechanism used to meet the requirements that apply to the
    interaction between the metadata server and the storage device
    such that they present a consistent interface to the client.
    Particular implementations may satisfy this requirement in any
    manner they choose and the mechanism chosen may not be described as
    a protocol.  Specifications defining Layout Types need to clearly
    show how implementations can meet the requirements discussed below,
    especially with respect to those that have security implications.
    In addition, such specifications may find it necessary to impose
    requirements on implementations of the layout type to ensure
    appropriate interoperability.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    protocol.  This is often described as using a "loose coupling" model.
    In such cases, the assumption is that the metadata server,
    storage devices, and client may be changed independently and that
    the implementation requirements in the layout type specification
    need to ensure this degree of interoperability.  This model is used
    in the block and object layout type specification.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    In other cases, it is assumed that there may be purpose-built control
    protocol which may be different for different implementations of the
    metadata server and data server.  In such cases, the assumption is
    that the metadata server and data servers are designed and implemented
    as a unit and interoperability needs to be assured between clients
    and metadata-data server pairs, developed independently. This is
    the model used for the files layout.
  </t>

  <t>
    In some cases, there may be no control protocol other than the storage
    Another possibility, not so far realized, is for the definition of
    a control protocol to be specified in a standards-track document.
    There are two subcases to consider:

    <list style='symbols'>
      <t>
        A new layout type includes a definition of a particular
        control protocol whose use is obligatory for metadata serverss
        and storage devices implementing the layout type.  In this case
        the interoperability model is similar to the first case above
        and the defining document should assure interoperability among
        metadata servers, storage devices, and clients developed
        independently.
      </t>

      <t>
        A control protocol is defined in a standards-track document
        which meets the control protocol requirements for one of the
        existing layout types.  In this case, the new document's job
        is to assure interoperability between metadata servers and
        storage devices developed separately.  The existing  definition
        document for the selected layout type retains the function of
        assuring interoperability between clients and a given collection
        of metadata servers and storage devices.  In this context,
        implementations that implement the new protocol are treated in
        the same way as those that use an internal control protocol or
        a functional equivalent.
      </t>
    </list>
  </t>

  <section anchor="sec:control:req" title="Protocol Requirements">
    <t>
      The broad requirements of such interactions between the metadata
      server and the storage devices are:

      <list style='format (%d)'>
        <t>
          NFSv4.1 clients MUST be able to access a file directly through the
          metadata server and not the storage device. I.e., the metadata
          server must be able to retrieve the data from the constituent
          storage devices and present it back to the client via normal NFSv4.1
          operations. Whether the metadata server allows access over other
          protocols (e.g., NFSv3, Server Message Block (SMB), etc) is
          strictly an implementation choice.
        </t>

        <t>
          The metadata server MUST be able to restrict access to a file
          on the storage devices when it revokes a layout. The metadata
          server typically would revoke a layout whenever a client fails
          to respond to a recall or fails to renew its lease in time. It
          might also revoke the layout as a means of enforcing a change
          in state that the storage device cannot directly enforce with
          the client.
        </t>

        <t>
          Storage devices MUST NOT remove NFSv4.1's access controls: ACLs and
          file open modes.
        </t>

        <t>
          Locking MUST be respected.
        </t>

        <t>
          The metadata server and the storage devices MUST agree on 
          attributes like modify time, the change attribute, and
          the end-of-file (EOF) position.
          <vspace blankLines="1"/>
          Note that "agree" here means that some state changes need not be propagated
          immediately, although all changes SHOULD be propagated promptly.
        </t>
      </list>
    </t>

    <t>
      Note that there is no requirement on how these are implemented. While the file layout
      type does use the stateid to fence off the client, there is no requirement that
      other layout types use this stateid approach. But the other layout types
      MUST document how the client, metadata server, and storage devices interact
      to meet these requirements.
    </t>
  </section>

  <section anchor="sec:control:nonreq" title="Non-protocol Requirements">
    <t>
      In gathering the requirements from Section 12 of <xref target='RFC5661' />,
      there are some which are notable in their absence:

      <list style='format (%d)'>
        <t>
          Storage device MUST honor the byte range restrictions present in the
          layout. I.e., if the layout only provides access to the first
          2 MB of the file, then any access after that MUST NOT be granted.
        </t>

        <t>
          The enforcement of
          authentication and authorization so that restrictions that would be
          enforced by the metadata server are also enforced by the storage device.
          Examples include both export access checks and if the layout has an iomode
          of LAYOUTIOMODE4_READ, then if the client attempts to write, the I/O may be rejected.
          <vspace blankLines="1"/>
          While storage devices should make such checks on the layout iomode, <xref target='RFC5661' />
          does not mandate that all layout types have to make such checks.
        </t>

        <t>
          The allocation and deallocation of storage. I.e., creating and deleting files.
        </t>
      </list>
    </t>

    <t>
      Of these, the first two are of concern to this draft and layout types SHOULD honor
      them if at all possible,
    </t>
  </section>

  <section anchor="sec:control:edits" title="Editorial Requirements">
    <t>
      In addition to these protocol requirements, there are two editorial requirements for drafts
      that present a new layout type. At a minimum, the specification needs to address:

      <list style='format (%d)'>
        <t>
          The approach the new layout type takes towards fencing clients once the
          metadata server determines that the layout is revoked.
        </t>

        <t>
          The security considerations of the new layout type.
        </t>
      </list>

      While these could be envisioned as one section in that the fencing issue might be
      the only security issue, it is recommended to deal with them separably.
    </t>

    <t>
      The specification of the layout type should discuss how the client, metadata server,
      and storage device act together to meet the protocol requirements. I.e., if the storage
      device cannot enforce mandatory byte-range locks, then how can the metadata
      server and the client interact with the layout to enforce those locks?
    </t>
  </section>
</section>
