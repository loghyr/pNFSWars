<!-- Copyright (C) The IETF Trust (2014) -->
<!-- Copyright (C) The Internet Society (2014) -->

<section anchor="sec:intro" title="Introduction">

  <t>
    The concept of layout type has a central role in the definition
    and implementation of Parallel Network File System (pNFS).
    Clients and servers implementing different layout types behave
    differently in many ways while conforming to the overall pNFS
    framework defined in <xref target='RFC5661' /> and this document.
    Layout types may differ in:

    <list style='symbols'>
      <t>
        The method used to do I/O operations directed to data storage devices.
      </t>

      <t>
        The requirements for communication between the metadata server (MDS) and
        the data storage devices.
      </t>

      <t>
        The means used to ensure that I/O requests
        are only processed when the client holds an appropriate layout.
      </t>

      <t>
        The format and interpretation of nominally opaque data fields in
        pNFS-related NFSv4.x data structures.
      </t>
    </list>
  </t>

  <t>
    Such matters are defined in a standards-track layout type
    specification.  Except for the files layout type, which was
    defined in Section 13 of <xref target='RFC5661' />, existing
    layout types are defined in their own standards-track documents
    and it is anticipated that new layout type will be defined in
    similar documents.
  </t>

  <t>
    The file layout type
    was defined in the Network File System (NFS) version 4.1
    protocol specification <xref target='RFC5661' />. The block
    layout type was defined in <xref target='RFC5663' /> and the object
    layout type was in turn defined in <xref target='RFC5664' />.
  </t>

  <t>
    Some implementers have interpreted the text in Sections 12
    ("Parallel NFS (pNFS)") and 13 ("NFSv4.1 as a Storage Protocol
    in pNFS: the File Layout Type") of <xref target='RFC5661' />
    as both being strictly for the file layout type. Because Section
    13 was not covered in a separate standards-track document like
    those for both the block and object layout types, there had
    been some confusion as to the responsibilities of both the
    metadata server and the data servers (DS) which were laid out
    in Section 12.
  </t>

  <t>
    As a consequence, new internet drafts (see <xref target='FlexFiles' />
    and <xref target='Lustre' />) may struggle to meet the requirements
    to be a pNFS layout type. This document specifies the
    layout type independent requirements placed on all layout types,
    whether one of the original three or any new variant.
  </t>
</section>

<section anchor='sec:defs' title='Definitions'>
  <t>
    <list style='hanging'>
      <t hangText='control communication requirements:'>
        define for a layout type the details regarding
        information on layouts, stateids, file metadata, and file
        data which must be  communicated between the metadata
        server and the storage devices.
      </t>

      <t hangText='control protocol:'>
        defines a particular mechanism that an implementation of a
        layout type would use to meet the control communication
        requirement for that layout type.  This need not be a
        protocol as normally understood.  In some cases the same
        protocol my be used as a control protocol and data access
        protocol.
      </t>

      <t hangText='(file) data:'>
        is that part of the file system object which contains
        the data to read or writen. It is the contents of the object
        and not the attributes of the object.
      </t>

      <t hangText='data server (DS):'>
        is a pNFS server which provides the file's data when the file
        system object is accessed over a file-based protocol.  Note
        that this usage differs from that in <xref target='RFC5661' /> which applies
        the term in some cases even when other sorts of protocols
        are being used. Depending on the layout, there might be one
        or more data servers over which the data is striped.
        While the metadata server is strictly accessed over
        the NFSv4.1 protocol, depending on the layout type, the
        data server could be accessed via any file access protocol
        that meets the pNFS requirements.
        <vspace blankLines='1' />
        See <xref target='sec:intro:diff' /> for a comparison of this
        term and "data storage device".
      </t>

      <t hangText='fencing:'>
        is when the metadata server prevents the storage devices
        from processing I/O from a specific client to a specific file.
      </t>

      <t hangText='layout:'>
        informs a client of which storage devices it needs to communicate
        with (and over which protocol) to perform I/O on a file. The
        layout might also provide some hints about how the storage
        is physically organized.
      </t>

      <t hangText='layout iomode:'>
        describes whether the layout granted to the client is for
        read or read/write I/O.
      </t>

      <t hangText='layout stateid:'>
        is a 128-bit quantity returned by a server that
        uniquely defines the layout state provided by the server
        for a specific layout that describes a layout type and
        file (see Section 12.5.2 of <xref target='RFC5661' />).
        Further, Section 12.5.3 describes the difference between
        a layout stateid and a normal stateid.
      </t>

      <t hangText='layout type:'>
        describes both the storage protocol used to
        access the data and the aggregation scheme used to lays out
        the file data on the underlying storage devices.
      </t>

      <t hangText='(file) metadata:'>
        is that part of the file system object which describes
        the object and not the payload. E.g., it could be the
        time since last modification, access, etc.
      </t>

      <t hangText='metadata server (MDS):'>
        is the pNFS server which provides metadata information
        for a file system object. It also is responsible for
        generating layouts for file system objects. Note that
        the MDS is responsible for directory-based operations.
      </t>

      <t hangText='recalling a layout:'>
        is when the metadata server uses a back channel to inform the client
        that the layout is to be returned in a graceful manner. Note that the client
        could be able to flush any writes, etc., before replying to
        the metadata server.
      </t>

      <t hangText='revoking a layout:'>
        is when the metadata server invalidates the layout such that neither
        the metadata server nor any storage device will accept any access from the client
        with that layout.
      </t>

      <t hangText='stateid:'>
        is a 128-bit quantity returned by a server that
        uniquely defines the open and locking states provided by the
        server for a specific open-owner or lock-owner/open-owner pair for
        a specific file and type of lock.
      </t>

      <t hangText='storage device:'>
        is another term used almost interchangeably with data server. See
        <xref target='sec:intro:diff' /> for the nuances between the two.
      </t>
    </list>
  </t>

  <section anchor='sec:intro:diff' title="Difference Between a Data Server and a Storage Device">
    <t>
      We defined a data server as a pNFS server, which implies that it
      can utilize the NFSv4.1 protocol to communicate with the client.
      As such, only the file layout type would currently meet this
      requirement. The more generic concept is a storage device, which
      can use any protocol to communicate with the client. The requirements
      for a storage device to act together with the metadata server
      to provide data to a client are that there is a layout type
      specification for the given protocol and that the metadata server
      has granted a layout to the client. Note that nothing precludes
      there being multiple supported layout types (i.e., protocols)
      between a metadata server, storage devices, and client.
    </t>

    <t>
      As storage device is the more encompassing terminology, this document
      utilizes it over data server.
    </t>
  </section>

  <section title="Requirements Language">
    <t>
      The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
      &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
      &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
      &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
      interpreted as described in <xref target="RFC2119" />.
    </t>
  </section>
</section>
